
# Detect loop in a linked list

Given a linked list, check if the linked list has loop or not. Below diagram shows a linked list with a loop.  

![](https://www.geeksforgeeks.org/wp-content/uploads/2009/04/Linked-List-Loop.gif "Click to enlarge")

Following are different ways of doing this

**Solution 1:  Hashing Approach:**
Traverse the list one by one and keep putting the node addresses in a Hash Table. At any point, if NULL is reached then return false and if next of current node points to any of the previously stored nodes in Hash then return true.
```c++
// Returns true if there is a loop in linked list
// else returns false.
bool detectLoop(struct Node * h) {
  unordered_set < Node * > s;
  while (h != NULL) {
    // If this node is already present
    // in hashmap it means there is a cycle
    // (Because you we encountering the
    // node for the second time).
    if (s.find(h) != s.end())
      return true;

    // If we are seeing the node for
    // the first time, insert it in hash
    s.insert(h);

    h = h -> next;
  }

  return false;
}
```
**Output**: ```true```

**Complexity Analysis:**

-   **Time complexity:**  O(n).  
    Only one traversal of the loop is needed.
-   **Auxiliary Space:**  O(n).  
    n is the space required to store the value in hashmap.
    
**Solution 2:** This problem can be solved without hashmap by modifying the linked list data-structure.  
**Approach:**  This solution requires modifications to the basic linked list data structure.

-   Have a visited flag with each node.
-   Traverse the linked list and keep marking visited nodes.
-   If you see a visited node again then there is a loop. This solution works in O(n) but requires additional information with each node.
-   A variation of this solution that doesn’t require modification to basic data structure can be implemented using a hash, just store the addresses of visited nodes in a hash and if you see an address that already exists in hash then there is a loop.
```c++
bool detectLoop(struct Node * h) {
  while (h != NULL) {
    // If this node is already traverse
    // it means there is a cycle
    // (Because you we encountering the
    // node for the second time).
    if (h -> flag == 1)
      return true;

    // If we are seeing the node for
    // the first time, mark its flag as 1
    h -> flag = 1;

    h = h -> next;
  }

  return false;
}
```
**Output**: ```true```

**Complexity Analysis:**

-   **Time complexity:**O(n).  
    Only one traversal of the loop is needed.
-   **Auxiliary Space:**O(1).  
    No extra space is needed.

**Solution 3: Floyd’s Cycle-Finding Algorithm**  
**Approach:**  This is the fastest method and has been described below:

-   Traverse linked list using two pointers.
-   Move one pointer(slow_p) by one and another pointer(fast_p) by two.
-   If these pointers meet at the same node then there is a loop. If pointers do not meet then linked list doesn’t have a loop.

Below image shows how the detectloop function works in the code :
![](https://media.geeksforgeeks.org/wp-content/cdn-uploads/20190621160855/Detect-loop-in-a-linked-list.png)

```c++
int detectLoop(Node * list) {
  Node * slow_p = list, * fast_p = list;

  while (slow_p && fast_p && fast_p -> next) {
    slow_p = slow_p -> next;
    fast_p = fast_p -> next -> next;
    if (slow_p == fast_p) {
      return 1;
    }
  }
  return 0;
}
```
**Output**: ```true```

**Complexity Analysis:**

-   **Time complexity:**  O(n).  
    Only one traversal of the loop is needed.
-   **Auxiliary Space:**O(1).  
    There is no space required.
