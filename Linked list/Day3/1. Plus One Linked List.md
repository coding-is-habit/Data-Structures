
## Plus One Linked List
Given a non-negative integer represented as a linked list of digits,  _plus one to the integer_.
 
The digits are stored such that the most significant digit is at the  `head`  of the list.
 
**Example 1:**
 
**Input:** head = 1->2->3
 
**Output:** 1->2->4
 
 
**Example 2:** 
 
**Input:** head = 0
 
**Output:** 1
### Intuition:
 
* Idea is to just reverse the linked list so we can access the nodes we need to increase sequentially.  
E.g. `1->2->3` --> `3->2->1` 
* Then just iteratively add a value and deal with carries if they arise by tracking with a variable.  
* If we reach the end of our list and still have a carry (like in the case of `9->9->9`, then we just add a new node at the end.  
* We have to reverse everything back at the end so it's back in proper left to right order.
 
```c++
ListNode* plusOne(ListNode* head) {
        
        ListNode* sentineal = new ListNode(0);
        sentineal->next = head;
        ListNode* notNine   = sentineal;
        if(head == NULL) return NULL;
        
        while(head != NULL){
            if(head->val != 9) notNine = head;
            head = head->next;
        }
        notNine->val++;
        notNine = notNine->next;
        while(notNine != NULL && notNine->val == 9 ){
            notNine->val = 0;
            notNine = notNine->next;
        }
        
        if(sentineal->val > 0){
            return sentineal;
        }
        return sentineal->next;
        
    }
```
 
**Time Complexity:** O(n), reverse the list and then again reverse it in O(n). 
 
**Space Complexity:** O(1) space though so, in theory, could be better than a recursive solution, which would require O(n) space for the callstack.
 
**[Video Tutorial](https://www.youtube.com/watch?v=utc8bwTDjLk)** 
 
**Practice this Problem:** [**Plus One**](https://leetcode.com/problems/plus-one-linked-list/)
